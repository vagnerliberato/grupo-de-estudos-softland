# Language zh-CN translations for PACKAGE package.
# Automatically generated, 2010.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-07-01 20:08+0000\n"
"PO-Revision-Date: 2010-07-01 20:08+0000\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh-CN\n"

#. Tag: title
#: mapping.xml:30
#, no-c-format
msgid "Mapping entities to the index structure"
msgstr ""

#. Tag: para
#: mapping.xml:32
#, no-c-format
msgid ""
"All the metadata information needed to index entities is described through "
"annotations. There is no need for xml mapping files. In fact there is "
"currently no xml configuration option available (see <ulink url=\"http://"
"opensource.atlassian.com/projects/hibernate/browse/"
"HSEARCH-210\">HSEARCH-210</ulink>). You can still use Hibernate mapping "
"files for the basic Hibernate configuration, but the Hibernate Search "
"specific configuration has to be expressed via annotations."
msgstr ""

#. Tag: title
#: mapping.xml:41
#, no-c-format
msgid "Mapping an entity"
msgstr ""

#. Tag: title
#: mapping.xml:44
#, no-c-format
msgid "Basic mapping"
msgstr ""

#. Tag: para
#: mapping.xml:46
#, no-c-format
msgid ""
"First, we must declare a persistent class as indexable. This is done by "
"annotating the class with <literal>@Indexed</literal> (all entities not "
"annotated with <literal>@Indexed</literal> will be ignored by the indexing "
"process):"
msgstr ""

#. Tag: title
#: mapping.xml:52
#, no-c-format
msgid ""
"Making a class indexable using the <classname>@Indexed</classname> annotation"
msgstr ""

#. Tag: programlisting
#: mapping.xml:55
#, no-c-format
msgid ""
"@Entity\n"
"<emphasis role=\"bold\">@Indexed(index=\"indexes/essays\")</emphasis>\n"
"public class Essay {\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:58
#, no-c-format
msgid ""
"The <literal>index</literal> attribute tells Hibernate what the Lucene "
"directory name is (usually a directory on your file system). It is "
"recommended to define a base directory for all Lucene indexes using the "
"<literal>hibernate.search.default.indexBase</literal> property in your "
"configuration file. Alternatively you can specify a base directory per "
"indexed entity by specifying <literal>hibernate.search.&lt;index&gt;."
"indexBase, </literal>where <literal>&lt;index&gt;</literal> is the fully "
"qualified classname of the indexed entity. Each entity instance will be "
"represented by a Lucene <classname>Document</classname> inside the given "
"index (aka Directory)."
msgstr ""

#. Tag: para
#: mapping.xml:70
#, no-c-format
msgid ""
"For each property (or attribute) of your entity, you have the ability to "
"describe how it will be indexed. The default (no annotation present) means "
"that the property is ignored by the indexing process. <literal>@Field</"
"literal> does declare a property as indexed. When indexing an element to a "
"Lucene document you can specify how it is indexed:"
msgstr ""

#. Tag: para
#: mapping.xml:79
#, no-c-format
msgid ""
"<literal>name</literal> : describe under which name, the property should be "
"stored in the Lucene Document. The default value is the property name "
"(following the JavaBeans convention)"
msgstr ""

#. Tag: para
#: mapping.xml:85
#, no-c-format
msgid ""
"<literal>store</literal> : describe whether or not the property is stored in "
"the Lucene index. You can store the value <literal>Store.YES</literal> "
"(consuming more space in the index but allowing projection, see <xref "
"linkend=\"projections\"/> for more information), store it in a compressed "
"way <literal>Store.COMPRESS</literal> (this does consume more CPU), or avoid "
"any storage <literal>Store.NO</literal> (this is the default value). When a "
"property is stored, you can retrieve its original value from the Lucene "
"Document. This is not related to whether the element is indexed or not."
msgstr ""

#. Tag: para
#: mapping.xml:98
#, no-c-format
msgid ""
"index: describe how the element is indexed and the type of information "
"store. The different values are <literal>Index.NO</literal> (no indexing, ie "
"cannot be found by a query), <literal>Index.TOKENIZED</literal> (use an "
"analyzer to process the property), <literal>Index.UN_TOKENIZED</literal> (no "
"analyzer pre-processing), <literal>Index.NO_NORMS</literal> (do not store "
"the normalization data). The default value is <literal>TOKENIZED</literal>."
msgstr ""

#. Tag: para
#: mapping.xml:109
#, no-c-format
msgid ""
"termVector: describes collections of term-frequency pairs. This attribute "
"enables term vectors being stored during indexing so they are available "
"within documents. The default value is TermVector.NO."
msgstr ""

#. Tag: para
#: mapping.xml:114
#, no-c-format
msgid "The different values of this attribute are:"
msgstr ""

#. Tag: entry
#: mapping.xml:120
#, no-c-format
msgid "Value"
msgstr ""

#. Tag: entry
#: mapping.xml:122
#, no-c-format
msgid "Definition"
msgstr ""

#. Tag: entry
#: mapping.xml:128
#, no-c-format
msgid "TermVector.YES"
msgstr ""

#. Tag: entry
#: mapping.xml:130
#, no-c-format
msgid ""
"Store the term vectors of each document. This produces two synchronized "
"arrays, one contains document terms and the other contains the term's "
"frequency."
msgstr ""

#. Tag: entry
#: mapping.xml:136
#, no-c-format
msgid "TermVector.NO"
msgstr ""

#. Tag: entry
#: mapping.xml:138
#, no-c-format
msgid "Do not store term vectors."
msgstr ""

#. Tag: entry
#: mapping.xml:142
#, no-c-format
msgid "TermVector.WITH_OFFSETS"
msgstr ""

#. Tag: entry
#: mapping.xml:144
#, no-c-format
msgid ""
"Store the term vector and token offset information. This is the same as "
"TermVector.YES plus it contains the starting and ending offset position "
"information for the terms."
msgstr ""

#. Tag: entry
#: mapping.xml:151
#, no-c-format
msgid "TermVector.WITH_POSITIONS"
msgstr ""

#. Tag: entry
#: mapping.xml:153
#, no-c-format
msgid ""
"Store the term vector and token position information. This is the same as "
"TermVector.YES plus it contains the ordinal positions of each occurrence of "
"a term in a document."
msgstr ""

#. Tag: entry
#: mapping.xml:160
#, no-c-format
msgid "TermVector.WITH_POSITION_OFFSETS"
msgstr ""

#. Tag: entry
#: mapping.xml:162
#, no-c-format
msgid ""
"Store the term vector, token position and offset information. This is a "
"combination of the YES, WITH_OFFSETS and WITH_POSITIONS."
msgstr ""

#. Tag: para
#: mapping.xml:172
#, no-c-format
msgid ""
"Whether or not you want to store the original data in the index depends on "
"how you wish to use the index query result. For a regular Hibernate Search "
"usage storing is not necessary. However you might want to store some fields "
"to subsequently project them (see <xref linkend=\"projections\"/> for more "
"information)."
msgstr ""

#. Tag: para
#: mapping.xml:178
#, no-c-format
msgid ""
"Whether or not you want to tokenize a property depends on whether you wish "
"to search the element as is, or by the words it contains. It make sense to "
"tokenize a text field, but probably not a date field."
msgstr ""

#. Tag: para
#: mapping.xml:182
#, no-c-format
msgid "Fields used for sorting must not be tokenized."
msgstr ""

#. Tag: para
#: mapping.xml:185
#, no-c-format
msgid ""
"Finally, the id property of an entity is a special property used by "
"Hibernate Search to ensure index unicity of a given entity. By design, an id "
"has to be stored and must not be tokenized. To mark a property as index id, "
"use the <literal>@DocumentId</literal> annotation. If you are using "
"Hibernate Annotations and you have specified @Id you can omit @DocumentId. "
"The chosen entity id will also be used as document id."
msgstr ""

#. Tag: title
#: mapping.xml:194
#, no-c-format
msgid ""
"Adding <classname>@DocumentId</classname> ad <classname>@Field</classname> "
"annotations to an indexed entity"
msgstr ""

#. Tag: programlisting
#: mapping.xml:197
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed(index=\"indexes/essays\")\n"
"public class Essay {\n"
"    ...\n"
"\n"
"    @Id\n"
"    <emphasis role=\"bold\">@DocumentId</emphasis>\n"
"    public Long getId() { return id; }\n"
"\n"
"    <emphasis role=\"bold\">@Field(name=\"Abstract\", index=Index.TOKENIZED, "
"store=Store.YES)</emphasis>\n"
"    public String getSummary() { return summary; }\n"
"\n"
"    @Lob\n"
"    <emphasis role=\"bold\">@Field(index=Index.TOKENIZED)</emphasis>\n"
"    public String getText() { return text; }\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:200
#, no-c-format
msgid ""
"define an index with three fields: <literal>id</literal> , "
"<literal>Abstract</literal> and <literal>text</literal> . Note that by "
"default the field name is decapitalized, following the JavaBean specification"
msgstr ""

#. Tag: title
#: mapping.xml:207
#, no-c-format
msgid "Mapping properties multiple times"
msgstr ""

#. Tag: para
#: mapping.xml:209
#, no-c-format
msgid ""
"Sometimes one has to map a property multiple times per index, with slightly "
"different indexing strategies. For example, sorting a query by field "
"requires the field to be <literal>UN_TOKENIZED</literal>. If one wants to "
"search by words in this property and still sort it, one need to index it "
"twice - once tokenized and once untokenized. @Fields allows to achieve this "
"goal."
msgstr ""

#. Tag: title
#: mapping.xml:217
#, no-c-format
msgid "Using @Fields to map a property multiple times"
msgstr ""

#. Tag: programlisting
#: mapping.xml:219
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed(index = \"Book\" )\n"
"public class Book {\n"
"    <emphasis role=\"bold\">@Fields( {</emphasis>\n"
"            @Field(index = Index.TOKENIZED),\n"
"            @Field(name = \"summary_forSort\", index = Index.UN_TOKENIZED, "
"store = Store.YES)\n"
"            <emphasis role=\"bold\">} )</emphasis>\n"
"    public String getSummary() {\n"
"        return summary;\n"
"    }\n"
"\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:222
#, no-c-format
msgid ""
"In <xref linkend=\"example-fields-annotation\"/> the field <literal>summary</"
"literal> is indexed twice, once as <literal>summary</literal> in a tokenized "
"way, and once as <literal>summary_forSort</literal> in an untokenized way. "
"@Field supports 2 attributes useful when @Fields is used:"
msgstr ""

#. Tag: para
#: mapping.xml:230
#, no-c-format
msgid ""
"analyzer: defines a @Analyzer annotation per field rather than per property"
msgstr ""

#. Tag: para
#: mapping.xml:235
#, no-c-format
msgid ""
"bridge: defines a @FieldBridge annotation per field rather than per property"
msgstr ""

#. Tag: para
#: mapping.xml:240
#, no-c-format
msgid "See below for more information about analyzers and field bridges."
msgstr ""

#. Tag: title
#: mapping.xml:245
#, no-c-format
msgid "Embedded and associated objects"
msgstr ""

#. Tag: para
#: mapping.xml:247
#, no-c-format
msgid ""
"Associated objects as well as embedded objects can be indexed as part of the "
"root entity index. This is useful if you expect to search a given entity "
"based on properties of associated objects. In the following example the aim "
"is to return places where the associated city is Atlanta (In the Lucene "
"query parser language, it would translate into <code>address.city:Atlanta</"
"code>)."
msgstr ""

#. Tag: title
#: mapping.xml:255
#, no-c-format
msgid "Using @IndexedEmbedded to index associations"
msgstr ""

#. Tag: programlisting
#: mapping.xml:257
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"public class Place {\n"
"    @Id\n"
"    @GeneratedValue\n"
"    @DocumentId\n"
"    private Long id;\n"
"\n"
"    @Field( index = Index.TOKENIZED )\n"
"    private String name;\n"
"\n"
"    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )\n"
"    <emphasis role=\"bold\">@IndexedEmbedded</emphasis>\n"
"    private Address address;\n"
"    ....\n"
"}\n"
"\n"
"@Entity\n"
"public class Address {\n"
"    @Id\n"
"    @GeneratedValue\n"
"    private Long id;\n"
"\n"
"    @Field(index=Index.TOKENIZED)\n"
"    private String street;\n"
"\n"
"    @Field(index=Index.TOKENIZED)\n"
"    private String city;\n"
"\n"
"    <emphasis role=\"bold\">@ContainedIn</emphasis>\n"
"    @OneToMany(mappedBy=\"address\")\n"
"    private Set&lt;Place&gt; places;\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:260
#, no-c-format
msgid ""
"In this example, the place fields will be indexed in the <literal>Place</"
"literal> index. The <literal>Place</literal> index documents will also "
"contain the fields <literal>address.id</literal>, <literal>address.street</"
"literal>, and <literal>address.city</literal> which you will be able to "
"query. This is enabled by the <literal>@IndexedEmbedded</literal> annotation."
msgstr ""

#. Tag: para
#: mapping.xml:267
#, no-c-format
msgid ""
"Be careful. Because the data is denormalized in the Lucene index when using "
"the <classname>@IndexedEmbedded</classname> technique, Hibernate Search "
"needs to be aware of any change in the <classname>Place</classname> object "
"and any change in the <classname>Address</classname> object to keep the "
"index up to date. To make sure the <literal><classname>Place</classname></"
"literal> Lucene document is updated when it's <classname>Address</classname> "
"changes, you need to mark the other side of the bidirectional relationship "
"with <classname>@ContainedIn</classname>."
msgstr ""

#. Tag: para
#: mapping.xml:277
#, no-c-format
msgid ""
"<literal>@ContainedIn</literal> is only useful on associations pointing to "
"entities as opposed to embedded (collection of) objects."
msgstr ""

#. Tag: para
#: mapping.xml:281
#, no-c-format
msgid "Let's make our example a bit more complex:"
msgstr ""

#. Tag: title
#: mapping.xml:284
#, no-c-format
msgid ""
"Nested usage of <classname>@IndexedEmbedded</classname> and "
"<classname>@ContainedIn</classname>"
msgstr ""

#. Tag: programlisting
#: mapping.xml:287
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"public class Place {\n"
"    @Id\n"
"    @GeneratedValue\n"
"    @DocumentId\n"
"    private Long id;\n"
"\n"
"    @Field( index = Index.TOKENIZED )\n"
"    private String name;\n"
"\n"
"    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )\n"
"    <emphasis role=\"bold\">@IndexedEmbedded</emphasis>\n"
"    private Address address;\n"
"    ....\n"
"}\n"
"\n"
"@Entity\n"
"public class Address {\n"
"    @Id\n"
"    @GeneratedValue\n"
"    private Long id;\n"
"\n"
"    @Field(index=Index.TOKENIZED)\n"
"    private String street;\n"
"\n"
"    @Field(index=Index.TOKENIZED)\n"
"    private String city;\n"
"\n"
"    <emphasis role=\"bold\">@IndexedEmbedded(depth = 1, prefix = \"ownedBy_"
"\")</emphasis>\n"
"    private Owner ownedBy;\n"
"\n"
"    <emphasis role=\"bold\">@ContainedIn</emphasis>\n"
"    @OneToMany(mappedBy=\"address\")\n"
"    private Set&lt;Place&gt; places;\n"
"    ...\n"
"}\n"
"\n"
"@Embeddable\n"
"public class Owner {\n"
"    @Field(index = Index.TOKENIZED)\n"
"    private String name;\n"
"   ...\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:290
#, no-c-format
msgid ""
"Any <literal>@*ToMany, @*ToOne</literal> and <literal>@Embedded</literal> "
"attribute can be annotated with <literal>@IndexedEmbedded</literal>. The "
"attributes of the associated class will then be added to the main entity "
"index. In the previous example, the index will contain the following fields"
msgstr ""

#. Tag: para
#: mapping.xml:298
#, no-c-format
msgid "<para>id</para>"
msgstr ""

#. Tag: para
#: mapping.xml:302
#, no-c-format
msgid "name"
msgstr ""

#. Tag: para
#: mapping.xml:306
#, no-c-format
msgid "address.street"
msgstr ""

#. Tag: para
#: mapping.xml:310
#, no-c-format
msgid "address.city"
msgstr ""

#. Tag: para
#: mapping.xml:314
#, no-c-format
msgid "address.ownedBy_name"
msgstr ""

#. Tag: para
#: mapping.xml:318
#, no-c-format
msgid ""
"The default prefix is <literal>propertyName.</literal>, following the "
"traditional object navigation convention. You can override it using the "
"<literal>prefix</literal> attribute as it is shown on the <literal>ownedBy</"
"literal> property."
msgstr ""

#. Tag: para
#: mapping.xml:324
#, no-c-format
msgid "The prefix cannot be set to the empty string."
msgstr ""

#. Tag: para
#: mapping.xml:327
#, no-c-format
msgid ""
"The<literal> depth</literal> property is necessary when the object graph "
"contains a cyclic dependency of classes (not instances). For example, if "
"<classname>Owner</classname> points to <classname>Place</classname>. "
"Hibernate Search will stop including Indexed embedded attributes after "
"reaching the expected depth (or the object graph boundaries are reached). A "
"class having a self reference is an example of cyclic dependency. In our "
"example, because <literal>depth</literal> is set to 1, any "
"<literal>@IndexedEmbedded</literal> attribute in Owner (if any) will be "
"ignored."
msgstr ""

#. Tag: para
#: mapping.xml:338
#, no-c-format
msgid ""
"Using <literal>@IndexedEmbedded</literal> for object associations allows you "
"to express queries such as:"
msgstr ""

#. Tag: para
#: mapping.xml:343
#, no-c-format
msgid ""
"Return places where name contains JBoss and where address city is Atlanta. "
"In Lucene query this would be"
msgstr ""

#. Tag: programlisting
#: mapping.xml:346
#, no-c-format
msgid "+name:jboss +address.city:atlanta"
msgstr ""

#. Tag: para
#: mapping.xml:350
#, no-c-format
msgid ""
"Return places where name contains JBoss and where owner's name contain Joe. "
"In Lucene query this would be"
msgstr ""

#. Tag: programlisting
#: mapping.xml:353
#, no-c-format
msgid "+name:jboss +address.orderBy_name:joe"
msgstr ""

#. Tag: para
#: mapping.xml:357
#, no-c-format
msgid ""
"In a way it mimics the relational join operation in a more efficient way (at "
"the cost of data duplication). Remember that, out of the box, Lucene indexes "
"have no notion of association, the join operation is simply non-existent. It "
"might help to keep the relational model normalized while benefiting from the "
"full text index speed and feature richness."
msgstr ""

#. Tag: para
#: mapping.xml:365
#, no-c-format
msgid ""
"An associated object can itself (but does not have to) be <literal>@Indexed</"
"literal>"
msgstr ""

#. Tag: para
#: mapping.xml:369
#, no-c-format
msgid ""
"When @IndexedEmbedded points to an entity, the association has to be "
"directional and the other side has to be annotated <literal>@ContainedIn</"
"literal> (as seen in the previous example). If not, Hibernate Search has no "
"way to update the root index when the associated entity is updated (in our "
"example, a <literal>Place</literal> index document has to be updated when "
"the associated <classname>Address</classname> instance is updated)."
msgstr ""

#. Tag: para
#: mapping.xml:377
#, no-c-format
msgid ""
"Sometimes, the object type annotated by <classname>@IndexedEmbedded</"
"classname> is not the object type targeted by Hibernate and Hibernate "
"Search. This is especially the case when interfaces are used in lieu of "
"their implementation. For this reason you can override the object type "
"targeted by Hibernate Search using the <methodname>targetElement</"
"methodname> parameter."
msgstr ""

#. Tag: title
#: mapping.xml:385
#, no-c-format
msgid ""
"Using the <literal>targetElement</literal> property of "
"<classname>@IndexedEmbedded</classname>"
msgstr ""

#. Tag: programlisting
#: mapping.xml:388
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"public class Address {\n"
"    @Id\n"
"    @GeneratedValue\n"
"    @DocumentId\n"
"    private Long id;\n"
"\n"
"    @Field(index= Index.TOKENIZED)\n"
"    private String street;\n"
"\n"
"    @IndexedEmbedded(depth = 1, prefix = \"ownedBy_\", <emphasis role=\"bold"
"\">targetElement = Owner.class</emphasis>)\n"
"    @Target(Owner.class)\n"
"    private Person ownedBy;\n"
"\n"
"\n"
"    ...\n"
"}\n"
"\n"
"@Embeddable\n"
"public class Owner implements Person { ... }"
msgstr ""

#. Tag: title
#: mapping.xml:393
#, no-c-format
msgid "Boost factor"
msgstr ""

#. Tag: para
#: mapping.xml:395
#, no-c-format
msgid ""
"Lucene has the notion of <emphasis>boost factor</emphasis>. It's a way to "
"give more weight to a field or to an indexed element over others during the "
"indexation process. You can use <literal>@Boost</literal> at the @Field, "
"method or class level."
msgstr ""

#. Tag: title
#: mapping.xml:401
#, no-c-format
msgid ""
"Using different ways of increasing the weight of an indexed element using a "
"boost factor"
msgstr ""

#. Tag: programlisting
#: mapping.xml:404
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed(index=\"indexes/essays\")\n"
"<emphasis role=\"bold\">@Boost(1.7f)</emphasis>\n"
"public class Essay {\n"
"    ...\n"
"\n"
"    @Id\n"
"    @DocumentId\n"
"    public Long getId() { return id; }\n"
"\n"
"    @Field(name=\"Abstract\", index=Index.TOKENIZED, store=Store.YES, "
"boost=<emphasis\n"
"            role=\"bold\">@Boost(2f)</emphasis>)\n"
"    <emphasis role=\"bold\">@Boost(1.5f)</emphasis>\n"
"    public String getSummary() { return summary; }\n"
"\n"
"    @Lob\n"
"    @Field(index=Index.TOKENIZED, boost=<emphasis role=\"bold\">@Boost(1.2f)"
"</emphasis>)\n"
"    public String getText() { return text; }\n"
"\n"
"    @Field\n"
"    public String getISBN() { return isbn; }\n"
"\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:407
#, no-c-format
msgid ""
"In our example, <classname>Essay</classname>'s probability to reach the top "
"of the search list will be multiplied by 1.7. The <methodname>summary</"
"methodname> field will be 3.0 (2 * 1.5 - <methodname>@Field.boost</"
"methodname> and <classname>@Boost</classname> on a property are cumulative) "
"more important than the <methodname>isbn</methodname> field. The "
"<methodname>text</methodname> field will be 1.2 times more important than "
"the <methodname>isbn</methodname> field. Note that this explanation in "
"strictest terms is actually wrong, but it is simple and close enough to "
"reality for all practical purposes. Please check the Lucene documentation or "
"the excellent <citetitle>Lucene In Action </citetitle> from Otis Gospodnetic "
"and Erik Hatcher."
msgstr ""

#. Tag: title
#: mapping.xml:422
#, no-c-format
msgid "Dynamic boost factor"
msgstr ""

#. Tag: para
#: mapping.xml:424
#, no-c-format
msgid ""
"The <literal>@Boost </literal>annotation used in <xref linkend=\"section-"
"boost-annotation\"/> defines a static boost factor which is is independent "
"of the state of of the indexed entity at runtime. However, there are "
"usecases in which the boost factor may depends on the actual state of the "
"entity. In this case you can use the <literal>@DynamicBoost </"
"literal>annotation together with an accompanying custom "
"<classname>BoostStrategy</classname>.<example id=\"example-dynamic-boosting"
"\"> <title>Dynamic boost examle</title> <programlisting>public enum "
"PersonType {\n"
"    NORMAL,\n"
"    VIP\n"
"}\n"
"\n"
"@Entity\n"
"@Indexed\n"
"<emphasis role=\"bold\">@DynamicBoost(impl = VIPBoostStrategy.class)</"
"emphasis>\n"
"public class Person {\n"
"    private PersonType type;   \n"
"    \n"
"    // ....\n"
"}\n"
"\n"
"public class VIPBoostStrategy implements BoostStrategy {\n"
"    <emphasis role=\"bold\">public float defineBoost(Object value)</"
"emphasis> {\n"
"        Person person = ( Person ) value;\n"
"        if ( person.getType().equals( PersonType.VIP ) ) {\n"
"            return 2.0f;\n"
"        }\n"
"        else {\n"
"            return 1.0f;\n"
"        }\n"
"    }\n"
"}</programlisting> </example>In <xref linkend=\"example-dynamic-boosting\"/> "
"a dynamic boost is defined on class level specifying "
"<classname>VIPBoostStrategy</classname> as implementation of the "
"<classname>BoostStrategy</classname> interface to be used at indexing time. "
"You can place the <literal>@DynamicBoost</literal> either at class or field "
"level. Depending on the placement of the annotation either the whole entity "
"is passed to the <methodname>defineBoost</methodname> method or just the "
"annotated field/property value. It's up to you to cast the passed object to "
"the correct type. In the example all indexed values of a VIP person would be "
"double as important as the values of a normal person.<note> <para>The "
"specified <classname>BoostStrategy</classname> implementation must define a "
"public no-arg constructor.</para> </note>Of course you can mix and match "
"<literal>@Boost</literal> and <literal>@DynamicBoost</literal> annotations "
"in your entity. All defined boost factors are cummulative as described in "
"<xref linkend=\"section-boost-annotation\"/>."
msgstr ""

#. Tag: title
#: mapping.xml:455
#, no-c-format
msgid "Analyzer"
msgstr ""

#. Tag: para
#: mapping.xml:457
#, no-c-format
msgid ""
"The default analyzer class used to index tokenized fields is configurable "
"through the <literal>hibernate.search.analyzer</literal> property. The "
"default value for this property is <classname>org.apache.lucene.analysis."
"standard.StandardAnalyzer</classname>."
msgstr ""

#. Tag: para
#: mapping.xml:462
#, no-c-format
msgid ""
"You can also define the analyzer class per entity, property and even per "
"@Field (useful when multiple fields are indexed from a single property)."
msgstr ""

#. Tag: title
#: mapping.xml:467
#, no-c-format
msgid "Different ways of specifying an analyzer"
msgstr ""

#. Tag: programlisting
#: mapping.xml:469
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"<emphasis role=\"bold\">@Analyzer(impl = EntityAnalyzer.class)</emphasis>\n"
"public class MyEntity {\n"
"    @Id\n"
"    @GeneratedValue\n"
"    @DocumentId\n"
"    private Integer id;\n"
"\n"
"    @Field(index = Index.TOKENIZED)\n"
"    private String name;\n"
"\n"
"    @Field(index = Index.TOKENIZED)\n"
"    <emphasis role=\"bold\">@Analyzer(impl = PropertyAnalyzer.class)</"
"emphasis>\n"
"    private String summary;\n"
"\n"
"    @Field(index = Index.TOKENIZED, <emphasis><emphasis role=\"bold"
"\">analyzer = @Analyzer(impl = FieldAnalyzer.class</emphasis>)</emphasis>\n"
"    private String body;\n"
"\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:472
#, no-c-format
msgid ""
"In this example, <classname>EntityAnalyzer</classname> is used to index all "
"tokenized properties (eg. <literal>name</literal>), except <literal>summary</"
"literal> and <literal>body</literal> which are indexed with "
"<classname>PropertyAnalyzer</classname> and <classname>FieldAnalyzer</"
"classname> respectively."
msgstr ""

#. Tag: para
#: mapping.xml:479
#, no-c-format
msgid ""
"Mixing different analyzers in the same entity is most of the time a bad "
"practice. It makes query building more complex and results less predictable "
"(for the novice), especially if you are using a QueryParser (which uses the "
"same analyzer for the whole query). As a rule of thumb, for any given field "
"the same analyzer should be used for indexing and querying."
msgstr ""

#. Tag: title
#: mapping.xml:488
#, no-c-format
msgid "Analyzer definitions"
msgstr ""

#. Tag: para
#: mapping.xml:490
#, no-c-format
msgid ""
"Analyzers can become quite complex to deal with for which reason Hibernate "
"Search introduces the notion of analyzer definitions. An analyzer definition "
"can be reused by many <classname>@Analyzer</classname> declarations. An "
"analyzer definition is composed of:"
msgstr ""

#. Tag: para
#: mapping.xml:498
#, no-c-format
msgid "a name: the unique string used to refer to the definition"
msgstr ""

#. Tag: para
#: mapping.xml:503
#, no-c-format
msgid ""
"a list of char filters: each char filter is responsible to pre-process input "
"characters before the tokenization. Char filters can add, change or remove "
"characters; one common usage is for characters normalization"
msgstr ""

#. Tag: para
#: mapping.xml:509
#, no-c-format
msgid ""
"a tokenizer: responsible for tokenizing the input stream into individual "
"words"
msgstr ""

#. Tag: para
#: mapping.xml:514
#, no-c-format
msgid ""
"a list of filters: each filter is responsible to remove, modify or sometimes "
"even add words into the stream provided by the tokenizer"
msgstr ""

#. Tag: para
#: mapping.xml:520
#, no-c-format
msgid ""
"This separation of tasks - a list of char filters, and a tokenizer followed "
"by a list of filters - allows for easy reuse of each individual component "
"and let you build your customized analyzer in a very flexible way (just like "
"Lego). Generally speaking the <classname>char filters</classname> do some "
"pre-processing in the character input, then the <classname>Tokenizer</"
"classname> starts the tokenizing process by turning the character input into "
"tokens which are then further processed by the <classname>TokenFilter</"
"classname>s. Hibernate Search supports this infrastructure by utilizing the "
"Solr analyzer framework. Make sure to add<filename> solr-core.jar and </"
"filename><filename>solr-solrj.jar</filename> to your classpath to use "
"analyzer definitions. In case you also want to use the snowball stemmer also "
"include the <filename>lucene-snowball.jar.</filename> Other Solr analyzers "
"might depend on more libraries. For example, the "
"<classname>PhoneticFilterFactory</classname> depends on <ulink url=\"http://"
"commons.apache.org/codec\">commons-codec</ulink>. Your distribution of "
"Hibernate Search provides these dependencies in its <filename>lib</filename> "
"directory."
msgstr ""

#. Tag: title
#: mapping.xml:540
#, no-c-format
msgid "<classname>@AnalyzerDef</classname> and the Solr framework"
msgstr ""

#. Tag: programlisting
#: mapping.xml:543
#, no-c-format
msgid ""
"@AnalyzerDef(name=\"customanalyzer\",\n"
"        charFilters = {\n"
"                @CharFilterDef(factory = MappingCharFilterFactory.class, "
"params = {\n"
"                    @Parameter(name = \"mapping\", value = \"org/hibernate/"
"search/test/analyzer/solr/mapping-chars.properties\")\n"
"                })\n"
"        },\n"
"        tokenizer = @TokenizerDef(factory = StandardTokenizerFactory."
"class),\n"
"        filters = {\n"
"                @TokenFilterDef(factory = ISOLatin1AccentFilterFactory."
"class),\n"
"                @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
"                @TokenFilterDef(factory = StopFilterFactory.class, params = "
"{\n"
"                    @Parameter(name=\"words\", value= \"org/hibernate/search/"
"test/analyzer/solr/stoplist.properties\" ),\n"
"                    @Parameter(name=\"ignoreCase\", value=\"true\")\n"
"                })\n"
"})\n"
"public class Team {\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:546
#, no-c-format
msgid ""
"A char filter is defined by its factory which is responsible for building "
"the char filter and using the optional list of parameters. In our example, a "
"mapping char filter is used, and will replace characters in the input based "
"on the rules specified in the mapping file. A tokenizer is also defined by "
"its factory. This example use the standard tokenizer. A filter is defined by "
"its factory which is responsible for creating the filter instance using the "
"optional parameters. In our example, the StopFilter filter is built reading "
"the dedicated words property file and is expected to ignore case. The list "
"of parameters is dependent on the tokenizer or filter factory."
msgstr ""

#. Tag: para
#: mapping.xml:559
#, no-c-format
msgid ""
"Filters and char filters are applied in the order they are defined in the "
"<classname>@AnalyzerDef</classname> annotation. Make sure to think twice "
"about this order."
msgstr ""

#. Tag: para
#: mapping.xml:564
#, no-c-format
msgid ""
"Once defined, an analyzer definition can be reused by an "
"<classname>@Analyzer</classname> declaration using the definition name "
"rather than declaring an implementation class."
msgstr ""

#. Tag: title
#: mapping.xml:569
#, no-c-format
msgid "Referencing an analyzer by name"
msgstr ""

#. Tag: programlisting
#: mapping.xml:571
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"@AnalyzerDef(name=\"customanalyzer\", ... )\n"
"public class Team {\n"
"    @Id\n"
"    @DocumentId\n"
"    @GeneratedValue\n"
"    private Integer id;\n"
"\n"
"    @Field\n"
"    private String name;\n"
"\n"
"    @Field\n"
"    private String location;\n"
"\n"
"    @Field <emphasis role=\"bold\">@Analyzer(definition = \"customanalyzer\")"
"</emphasis>\n"
"    private String description;\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:574
#, no-c-format
msgid ""
"Analyzer instances declared by <classname>@AnalyzerDef</classname> are "
"available by their name in the <classname>SearchFactory</classname>."
msgstr ""

#. Tag: programlisting
#: mapping.xml:578
#, no-c-format
msgid ""
"Analyzer analyzer = fullTextSession.getSearchFactory().getAnalyzer"
"(\"customanalyzer\");"
msgstr ""

#. Tag: para
#: mapping.xml:580
#, no-c-format
msgid ""
"This is quite useful wen building queries. Fields in queries should be "
"analyzed with the same analyzer used to index the field so that they speak a "
"common \"language\": the same tokens are reused between the query and the "
"indexing process. This rule has some exceptions but is true most of the "
"time. Respect it unless you know what you are doing."
msgstr ""

#. Tag: title
#: mapping.xml:589
#, no-c-format
msgid "Available analyzers"
msgstr ""

#. Tag: para
#: mapping.xml:591
#, no-c-format
msgid ""
"Solr and Lucene come with a lot of useful default char filters, tokenizers "
"and filters. You can find a complete list of char filter factories, "
"tokenizer factories and filter factories at <ulink url=\"http://wiki.apache."
"org/solr/AnalyzersTokenizersTokenFilters\">http://wiki.apache.org/solr/"
"AnalyzersTokenizersTokenFilters</ulink>. Let check a few of them."
msgstr ""

#. Tag: title
#: mapping.xml:598
#, no-c-format
msgid "Some of the available char filters"
msgstr ""

#. Tag: entry
#: mapping.xml:602 mapping.xml:639 mapping.xml:674
#, no-c-format
msgid "Factory"
msgstr ""

#. Tag: entry
#: mapping.xml:604 mapping.xml:641 mapping.xml:676
#, no-c-format
msgid "Description"
msgstr ""

#. Tag: entry
#: mapping.xml:606 mapping.xml:643 mapping.xml:678
#, no-c-format
msgid "parameters"
msgstr ""

#. Tag: entry
#: mapping.xml:611
#, no-c-format
msgid "MappingCharFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:613
#, no-c-format
msgid ""
"Replaces one or more characters with one or more characters, based on "
"mappings specified in the resource file"
msgstr ""

#. Tag: para
#: mapping.xml:616
#, no-c-format
msgid ""
"<literal>mapping</literal>: points to a resource file containing the "
"mappings using the format:"
msgstr ""

#. Tag: literallayout
#: mapping.xml:618
#, no-c-format
msgid ""
"\"á\" => \"a\"\n"
"                    \"ñ\" => \"n\"\n"
"                    \"ø\" => \"o\""
msgstr ""

#. Tag: entry
#: mapping.xml:622
#, no-c-format
msgid "HTMLStripCharFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:624
#, no-c-format
msgid "Remove HTML standard tags, keeping the text"
msgstr ""

#. Tag: entry
#: mapping.xml:626 mapping.xml:653 mapping.xml:662 mapping.xml:688
#: mapping.xml:696 mapping.xml:728
#, no-c-format
msgid "none"
msgstr ""

#. Tag: title
#: mapping.xml:634
#, no-c-format
msgid "Some of the available tokenizers"
msgstr ""

#. Tag: entry
#: mapping.xml:649
#, no-c-format
msgid "StandardTokenizerFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:651
#, no-c-format
msgid "Use the Lucene StandardTokenizer"
msgstr ""

#. Tag: entry
#: mapping.xml:657
#, no-c-format
msgid "HTMLStripStandardTokenizerFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:659
#, no-c-format
msgid ""
"Remove HTML tags, keep the text and pass it to a StandardTokenizer. "
"@Deprecated, use the HTMLStripCharFilterFactory instead"
msgstr ""

#. Tag: title
#: mapping.xml:669
#, no-c-format
msgid "Some of the available filters"
msgstr ""

#. Tag: entry
#: mapping.xml:684
#, no-c-format
msgid "StandardFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:686
#, no-c-format
msgid "Remove dots from acronyms and 's from words"
msgstr ""

#. Tag: entry
#: mapping.xml:692
#, no-c-format
msgid "LowerCaseFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:694
#, no-c-format
msgid "Lowercase words"
msgstr ""

#. Tag: entry
#: mapping.xml:700
#, no-c-format
msgid "StopFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:702
#, no-c-format
msgid "remove words (tokens) matching a list of stop words"
msgstr ""

#. Tag: para
#: mapping.xml:705
#, no-c-format
msgid ""
"<literal>words</literal>: points to a resource file containing the stop words"
msgstr ""

#. Tag: para
#: mapping.xml:706
#, no-c-format
msgid ""
"ignoreCase: true if <literal>case</literal> should be ignore when comparing "
"stop words, <literal>false</literal> otherwise"
msgstr ""

#. Tag: entry
#: mapping.xml:712
#, no-c-format
msgid "SnowballPorterFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:714
#, no-c-format
msgid ""
"Reduces a word to it's root in a given language. (eg. protect, protects, "
"protection share the same root). Using such a filter allows searches "
"matching related words."
msgstr ""

#. Tag: entry
#: mapping.xml:718
#, no-c-format
msgid ""
"<literal>language</literal>: Danish, Dutch, English, Finnish, French, "
"German, Italian, Norwegian, Portuguese, Russian, Spanish, Swedish and a few "
"more"
msgstr ""

#. Tag: entry
#: mapping.xml:724
#, no-c-format
msgid "ISOLatin1AccentFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:726
#, no-c-format
msgid "remove accents for languages like French"
msgstr ""

#. Tag: para
#: mapping.xml:734
#, no-c-format
msgid ""
"We recommend to check all the implementations of <classname>org.apache.solr."
"analysis.TokenizerFactory</classname> and <classname>org.apache.solr."
"analysis.TokenFilterFactory</classname> in your IDE to see the "
"implementations available."
msgstr ""

#. Tag: title
#: mapping.xml:741
#, no-c-format
msgid "Analyzer discriminator (experimental)"
msgstr ""

#. Tag: para
#: mapping.xml:743
#, no-c-format
msgid ""
"So far all the introduced ways to specify an analyzer were static. However, "
"there are use cases where it is useful to select an analyzer depending on "
"the current state of the entity to be indexed, for example in multilingual "
"applications. For an <classname>BlogEntry</classname> class for example the "
"analyzer could depend on the language property of the entry. Depending on "
"this property the correct language specific stemmer should be chosen to "
"index the actual text."
msgstr ""

#. Tag: para
#: mapping.xml:752
#, no-c-format
msgid ""
"To enable this dynamic analyzer selection Hibernate Search introduces the "
"<classname>AnalyzerDiscriminator</classname> annotation. The following "
"example demonstrates the usage of this annotation:"
msgstr ""

#. Tag: title
#: mapping.xml:758
#, no-c-format
msgid ""
"Usage of @AnalyzerDiscriminator in order to select an analyzer depending on "
"the entity state"
msgstr ""

#. Tag: programlisting
#: mapping.xml:761
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"@AnalyzerDefs({\n"
"  @AnalyzerDef(name = \"en\",\n"
"    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),\n"
"    filters = {\n"
"      @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
"      @TokenFilterDef(factory = EnglishPorterFilterFactory.class\n"
"      )\n"
"    }),\n"
"  @AnalyzerDef(name = \"de\",\n"
"    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),\n"
"    filters = {\n"
"      @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
"      @TokenFilterDef(factory = GermanStemFilterFactory.class)\n"
"    })\n"
"})\n"
"public class BlogEntry {\n"
"\n"
"    @Id\n"
"    @GeneratedValue\n"
"    @DocumentId\n"
"    private Integer id;\n"
"\n"
"    @Field\n"
"    @AnalyzerDiscriminator(impl = LanguageDiscriminator.class)\n"
"    private String language;\n"
"    \n"
"    @Field\n"
"    private String text;\n"
"    \n"
"    private Set&lt;BlogEntry&gt; references;\n"
"\n"
"    // standard getter/setter\n"
"    ...\n"
"}"
msgstr ""

#. Tag: programlisting
#: mapping.xml:763
#, no-c-format
msgid ""
"public class LanguageDiscriminator implements Discriminator {\n"
"\n"
"    public String getAnalyzerDefinitionName(Object value, Object entity, "
"String field) {\n"
"        if ( value == null || !( entity instanceof Article ) ) {\n"
"            return null;\n"
"        }\n"
"        return (String) value;\n"
"    }\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:766
#, no-c-format
msgid ""
"The prerequisite for using <classname>@AnalyzerDiscriminator</classname> is "
"that all analyzers which are going to be used are predefined via "
"<classname>@AnalyzerDef</classname> definitions. If this is the case one can "
"place the <classname>@AnalyzerDiscriminator</classname> annotation either on "
"the class or on a specific property of the entity for which to dynamically "
"select an analyzer. Via the <literal>impl</literal> parameter of the "
"<classname>AnalyzerDiscriminator</classname> you specify a concrete "
"implementation of the <classname>Discriminator</classname> interface. It is "
"up to you to provide an implementation for this interface. The only method "
"you have to implement is <classname>getAnalyzerDefinitionName()</classname> "
"which gets called for each field added to the Lucene document. The entity "
"which is getting indexed is also passed to the interface method. The "
"<literal>value</literal> parameter is only set if the "
"<classname>AnalyzerDiscriminator</classname> is placed on property level "
"instead of class level. In this case the value represents the current value "
"of this property."
msgstr ""

#. Tag: para
#: mapping.xml:786
#, no-c-format
msgid ""
"An implemention of the <classname>Discriminator</classname> interface has to "
"return the name of an existing analyzer definition if the analyzer should be "
"set dynamically or <classname>null</classname> if the default analyzer "
"should not be overridden. The given example assumes that the language "
"parameter is either 'de' or 'en' which matches the specified names in the "
"<classname>@AnalyzerDef</classname>s."
msgstr ""

#. Tag: para
#: mapping.xml:795
#, no-c-format
msgid ""
"The <classname>@AnalyzerDiscriminator</classname> is currently still "
"experimental and the API might still change. We are hoping for some feedback "
"from the community about the usefulness and usability of this feature."
msgstr ""

#. Tag: title
#: mapping.xml:803
#, no-c-format
msgid "Retrieving an analyzer"
msgstr ""

#. Tag: para
#: mapping.xml:805
#, no-c-format
msgid ""
"During indexing time, Hibernate Search is using analyzers under the hood for "
"you. In some situations, retrieving analyzers can be handy. If your domain "
"model makes use of multiple analyzers (maybe to benefit from stemming, use "
"phonetic approximation and so on), you need to make sure to use the same "
"analyzers when you build your query."
msgstr ""

#. Tag: para
#: mapping.xml:813
#, no-c-format
msgid ""
"This rule can be broken but you need a good reason for it. If you are "
"unsure, use the same analyzers."
msgstr ""

#. Tag: para
#: mapping.xml:817
#, no-c-format
msgid ""
"You can retrieve the scoped analyzer for a given entity used at indexing "
"time by Hibernate Search. A scoped analyzer is an analyzer which applies the "
"right analyzers depending on the field indexed: multiple analyzers can be "
"defined on a given entity each one working on an individual field, a scoped "
"analyzer unify all these analyzers into a context-aware analyzer. While the "
"theory seems a bit complex, using the right analyzer in a query is very easy."
msgstr ""

#. Tag: title
#: mapping.xml:826
#, no-c-format
msgid "Using the scoped analyzer when building a full-text query"
msgstr ""

#. Tag: programlisting
#: mapping.xml:829
#, no-c-format
msgid ""
"org.apache.lucene.queryParser.QueryParser parser = new QueryParser(\n"
"    \"title\", \n"
"    fullTextSession.getSearchFactory().getAnalyzer( Song.class )\n"
");\n"
"\n"
"org.apache.lucene.search.Query luceneQuery = \n"
"    parser.parse( \"title:sky Or title_stemmed:diamond\" );\n"
"\n"
"org.hibernate.Query fullTextQuery = \n"
"    fullTextSession.createFullTextQuery( luceneQuery, Song.class );\n"
"\n"
"List result = fullTextQuery.list(); //return a list of managed objects"
msgstr ""

#. Tag: para
#: mapping.xml:832
#, no-c-format
msgid ""
"In the example above, the song title is indexed in two fields: the standard "
"analyzer is used in the field <literal>title</literal> and a stemming "
"analyzer is used in the field <literal>title_stemmed</literal>. By using the "
"analyzer provided by the search factory, the query uses the appropriate "
"analyzer depending on the field targeted."
msgstr ""

#. Tag: para
#: mapping.xml:839
#, no-c-format
msgid ""
"If your query targets more that one query and you wish to use your standard "
"analyzer, make sure to describe it using an analyzer definition. You can "
"retrieve analyzers by their definition name using <code>searchFactory."
"getAnalyzer(String)</code>."
msgstr ""

#. Tag: title
#: mapping.xml:848
#, no-c-format
msgid "Property/Field Bridge"
msgstr ""

#. Tag: para
#: mapping.xml:850
#, no-c-format
msgid ""
"In Lucene all index fields have to be represented as Strings. For this "
"reason all entity properties annotated with <literal>@Field</literal> have "
"to be indexed in a String form. For most of your properties, Hibernate "
"Search does the translation job for you thanks to a built-in set of bridges. "
"In some cases, though you need a more fine grain control over the "
"translation process."
msgstr ""

#. Tag: title
#: mapping.xml:858
#, no-c-format
msgid "Built-in bridges"
msgstr ""

#. Tag: para
#: mapping.xml:860
#, no-c-format
msgid ""
"Hibernate Search comes bundled with a set of built-in bridges between a Java "
"property type and its full text representation."
msgstr ""

#. Tag: term
#: mapping.xml:865
#, no-c-format
msgid "null"
msgstr ""

#. Tag: para
#: mapping.xml:868
#, no-c-format
msgid ""
"null elements are not indexed. Lucene does not support null elements and "
"this does not make much sense either."
msgstr ""

#. Tag: term
#: mapping.xml:874
#, no-c-format
msgid "java.lang.String"
msgstr ""

#. Tag: para
#: mapping.xml:877
#, no-c-format
msgid "String are indexed as is"
msgstr ""

#. Tag: term
#: mapping.xml:882
#, no-c-format
msgid ""
"short, Short, integer, Integer, long, Long, float, Float, double, Double, "
"BigInteger, BigDecimal"
msgstr ""

#. Tag: para
#: mapping.xml:886
#, no-c-format
msgid ""
"Numbers are converted in their String representation. Note that numbers "
"cannot be compared by Lucene (ie used in ranged queries) out of the box: "
"they have to be padded"
msgstr ""

#. Tag: para
#: mapping.xml:889
#, no-c-format
msgid ""
"Using a Range query is debatable and has drawbacks, an alternative approach "
"is to use a Filter query which will filter the result query to the "
"appropriate range."
msgstr ""

#. Tag: para
#: mapping.xml:893
#, no-c-format
msgid "Hibernate Search will support a padding mechanism"
msgstr ""

#. Tag: term
#: mapping.xml:899
#, no-c-format
msgid "java.util.Date"
msgstr ""

#. Tag: para
#: mapping.xml:902
#, no-c-format
msgid ""
"Dates are stored as yyyyMMddHHmmssSSS in GMT time (200611072203012 for Nov "
"7th of 2006 4:03PM and 12ms EST). You shouldn't really bother with the "
"internal format. What is important is that when using a DateRange Query, you "
"should know that the dates have to be expressed in GMT time."
msgstr ""

#. Tag: para
#: mapping.xml:908
#, no-c-format
msgid ""
"Usually, storing the date up to the millisecond is not necessary. "
"<literal>@DateBridge</literal> defines the appropriate resolution you are "
"willing to store in the index ( <literal> <literal>@DateBridge"
"(resolution=Resolution.DAY)</literal> </literal> ). The date pattern will "
"then be truncated accordingly."
msgstr ""

#. Tag: programlisting
#: mapping.xml:915
#, no-c-format
msgid ""
"@Entity \n"
"@Indexed\n"
"public class Meeting {\n"
"    @Field(index=Index.UN_TOKENIZED)\n"
"    <emphasis role=\"bold\">@DateBridge(resolution=Resolution.MINUTE)</"
"emphasis>\n"
"    private Date date;\n"
"    ..."
msgstr ""

#. Tag: para
#: mapping.xml:918
#, no-c-format
msgid ""
"A Date whose resolution is lower than <literal>MILLISECOND</literal> cannot "
"be a <literal>@DocumentId</literal>"
msgstr ""

#. Tag: term
#: mapping.xml:926
#, no-c-format
msgid "java.net.URI, java.net.URL"
msgstr ""

#. Tag: para
#: mapping.xml:929
#, no-c-format
msgid "URI and URL are converted to their string representation"
msgstr ""

#. Tag: term
#: mapping.xml:935
#, no-c-format
msgid "java.lang.Class"
msgstr ""

#. Tag: para
#: mapping.xml:938
#, no-c-format
msgid ""
"Class are converted to their fully qualified class name. The thread context "
"classloader is used when the class is rehydrated"
msgstr ""

#. Tag: title
#: mapping.xml:947
#, no-c-format
msgid "Custom Bridge"
msgstr ""

#. Tag: para
#: mapping.xml:949
#, no-c-format
msgid ""
"Sometimes, the built-in bridges of Hibernate Search do not cover some of "
"your property types, or the String representation used by the bridge does "
"not meet your requirements. The following paragraphs describe several "
"solutions to this problem."
msgstr ""

#. Tag: title
#: mapping.xml:955
#, no-c-format
msgid "StringBridge"
msgstr ""

#. Tag: para
#: mapping.xml:957
#, no-c-format
msgid ""
"The simplest custom solution is to give Hibernate Search an implementation "
"of your expected <emphasis><classname>Object</classname> </emphasis>to "
"<classname>String</classname> bridge. To do so you need to implements the "
"<literal>org.hibernate.search.bridge.StringBridge</literal> interface. All "
"implementations have to be thread-safe as they are used concurrently."
msgstr ""

#. Tag: title
#: mapping.xml:966
#, no-c-format
msgid "Implementing your own <classname>StringBridge</classname>"
msgstr ""

#. Tag: programlisting
#: mapping.xml:969
#, no-c-format
msgid ""
"/**\n"
" * Padding Integer bridge.\n"
" * All numbers will be padded with 0 to match 5 digits\n"
" *\n"
" * @author Emmanuel Bernard\n"
" */\n"
"public class PaddedIntegerBridge implements <emphasis role=\"bold"
"\">StringBridge</emphasis> {\n"
"\n"
"    private int PADDING = 5;\n"
"\n"
"    <emphasis role=\"bold\">public String objectToString(Object object)</"
"emphasis> {\n"
"        String rawInteger = ( (Integer) object ).toString();\n"
"        if (rawInteger.length() &gt; PADDING) \n"
"            throw new IllegalArgumentException( \"Try to pad on a number too "
"big\" );\n"
"        StringBuilder paddedInteger = new StringBuilder( );\n"
"        for ( int padIndex = rawInteger.length() ; padIndex &lt; PADDING ; "
"padIndex++ ) {\n"
"            paddedInteger.append('0');\n"
"        }\n"
"        return paddedInteger.append( rawInteger ).toString();\n"
"    }\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:972
#, no-c-format
msgid ""
"Then any property or field can use this bridge thanks to the "
"<literal>@FieldBridge</literal> annotation"
msgstr ""

#. Tag: programlisting
#: mapping.xml:975
#, no-c-format
msgid ""
"<emphasis role=\"bold\">@FieldBridge(impl = PaddedIntegerBridge.class)</"
"emphasis>\n"
"private Integer length;"
msgstr ""

#. Tag: para
#: mapping.xml:977
#, no-c-format
msgid ""
"Parameters can be passed to the Bridge implementation making it more "
"flexible. The Bridge implementation implements a "
"<classname>ParameterizedBridge</classname> interface, and the parameters are "
"passed through the <literal>@FieldBridge</literal> annotation."
msgstr ""

#. Tag: title
#: mapping.xml:984
#, no-c-format
msgid "Passing parameters to your bridge implementation"
msgstr ""

#. Tag: programlisting
#: mapping.xml:986
#, no-c-format
msgid ""
"public class PaddedIntegerBridge implements StringBridge, <emphasis\n"
"              role=\"bold\">ParameterizedBridge</emphasis> {\n"
"\n"
"    public static String PADDING_PROPERTY = \"padding\";\n"
"    private int padding = 5; //default\n"
"\n"
"    <emphasis role=\"bold\">public void setParameterValues(Map parameters)</"
"emphasis> {\n"
"        Object padding = parameters.get( PADDING_PROPERTY );\n"
"        if (padding != null) this.padding = (Integer) padding;\n"
"    }\n"
"\n"
"    public String objectToString(Object object) {\n"
"        String rawInteger = ( (Integer) object ).toString();\n"
"        if (rawInteger.length() &gt; padding) \n"
"            throw new IllegalArgumentException( \"Try to pad on a number too "
"big\" );\n"
"        StringBuilder paddedInteger = new StringBuilder( );\n"
"        for ( int padIndex = rawInteger.length() ; padIndex &lt; padding ; "
"padIndex++ ) {\n"
"            paddedInteger.append('0');\n"
"        }\n"
"        return paddedInteger.append( rawInteger ).toString();\n"
"    }\n"
"}\n"
"\n"
"\n"
"//property\n"
"@FieldBridge(impl = PaddedIntegerBridge.class,\n"
"             <emphasis role=\"bold\">params = @Parameter(name=\"padding\", "
"value=\"10\")</emphasis>\n"
"            )\n"
"private Integer length;"
msgstr ""

#. Tag: para
#: mapping.xml:989
#, no-c-format
msgid ""
"The <classname>ParameterizedBridge</classname> interface can be implemented "
"by <classname>StringBridge</classname>, <classname>TwoWayStringBridge</"
"classname>, <classname>FieldBridge</classname> implementations."
msgstr ""

#. Tag: para
#: mapping.xml:994
#, no-c-format
msgid ""
"All implementations have to be thread-safe, but the parameters are set "
"during initialization and no special care is required at this stage."
msgstr ""

#. Tag: para
#: mapping.xml:998
#, no-c-format
msgid ""
"If you expect to use your bridge implementation on an id property (ie "
"annotated with <literal>@DocumentId</literal> ), you need to use a slightly "
"extended version of <literal>StringBridge</literal> named "
"<classname>TwoWayStringBridge</classname>. Hibernate Search needs to read "
"the string representation of the identifier and generate the object out of "
"it. There is no difference in the way the <literal>@FieldBridge</literal> "
"annotation is used."
msgstr ""

#. Tag: title
#: mapping.xml:1007
#, no-c-format
msgid ""
"Implementing a TwoWayStringBridge which can for example be used for id "
"properties"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1010
#, no-c-format
msgid ""
"public class PaddedIntegerBridge implements TwoWayStringBridge, "
"ParameterizedBridge {\n"
"\n"
"    public static String PADDING_PROPERTY = \"padding\";\n"
"    private int padding = 5; //default\n"
"\n"
"    public void setParameterValues(Map parameters) {\n"
"        Object padding = parameters.get( PADDING_PROPERTY );\n"
"        if (padding != null) this.padding = (Integer) padding;\n"
"    }\n"
"\n"
"    public String objectToString(Object object) {\n"
"        String rawInteger = ( (Integer) object ).toString();\n"
"        if (rawInteger.length() &gt; padding) \n"
"            throw new IllegalArgumentException( \"Try to pad on a number too "
"big\" );\n"
"        StringBuilder paddedInteger = new StringBuilder( );\n"
"        for ( int padIndex = rawInteger.length() ; padIndex &lt; padding ; "
"padIndex++ ) {\n"
"            paddedInteger.append('0');\n"
"        }\n"
"        return paddedInteger.append( rawInteger ).toString();\n"
"    }\n"
"\n"
"    <emphasis role=\"bold\">public Object stringToObject(String stringValue)"
"</emphasis> {\n"
"        return new Integer(stringValue);\n"
"    }\n"
"}\n"
"\n"
"\n"
"//id property\n"
"@DocumentId\n"
"@FieldBridge(impl = PaddedIntegerBridge.class,\n"
"             params = @Parameter(name=\"padding\", value=\"10\") \n"
"private Integer id;"
msgstr ""

#. Tag: para
#: mapping.xml:1013
#, no-c-format
msgid ""
"It is critically important for the two-way process to be idempotent (ie "
"object = stringToObject( objectToString( object ) ) )."
msgstr ""

#. Tag: title
#: mapping.xml:1019
#, no-c-format
msgid "FieldBridge"
msgstr ""

#. Tag: para
#: mapping.xml:1021
#, no-c-format
msgid ""
"Some use cases require more than a simple object to string translation when "
"mapping a property to a Lucene index. To give you the greatest possible "
"flexibility you can also implement a bridge as a <classname>FieldBridge</"
"classname>. This interface gives you a property value and let you map it the "
"way you want in your Lucene <classname>Document</classname>. The interface "
"is very similar in its concept to the Hibernate <classname>UserType</"
"classname>s."
msgstr ""

#. Tag: para
#: mapping.xml:1029
#, no-c-format
msgid ""
"You can for example store a given property in two different document fields:"
msgstr ""

#. Tag: title
#: mapping.xml:1033
#, no-c-format
msgid ""
"Implementing the FieldBridge interface in order to a given property into "
"multiple document fields"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1036
#, no-c-format
msgid ""
"/**\n"
" * Store the date in 3 different fields - year, month, day - to ease Range "
"Query per\n"
" * year, month or day (eg get all the elements of December for the last 5 "
"years).\n"
" * @author Emmanuel Bernard\n"
" */\n"
"public class DateSplitBridge implements FieldBridge {\n"
"    private final static TimeZone GMT = TimeZone.getTimeZone(\"GMT\");\n"
"\n"
"    <emphasis role=\"bold\">public void set(String name, Object value, "
"Document document, \n"
"                    LuceneOptions luceneOptions)</emphasis> {\n"
"        Date date = (Date) value;\n"
"        Calendar cal = GregorianCalendar.getInstance(GMT);\n"
"        cal.setTime(date);\n"
"        int year = cal.get(Calendar.YEAR);\n"
"        int month = cal.get(Calendar.MONTH) + 1;\n"
"        int day = cal.get(Calendar.DAY_OF_MONTH);\n"
"  \n"
"        // set year\n"
"        luceneOptions.addFieldToDocument(\n"
"            name + \".year\",\n"
"            String.valueOf( year ),\n"
"            document );\n"
"  \n"
"        // set month and pad it if needed\n"
"        luceneOptions.addFieldToDocument(\n"
"            name + \".month\",\n"
"            month &lt; 10 ? \"0\" : \"\" + String.valueOf( month ),\n"
"            document );\n"
"  \n"
"        // set day and pad it if needed\n"
"        luceneOptions.addFieldToDocument(\n"
"            name + \".day\",\n"
"            day &lt; 10 ? \"0\" : \"\" + String.valueOf( day ),\n"
"            document );\n"
"    }\n"
"}\n"
"\n"
"//property\n"
"<emphasis role=\"bold\">@FieldBridge(impl = DateSplitBridge.class)</"
"emphasis>\n"
"private Date date;"
msgstr ""

#. Tag: para
#: mapping.xml:1039
#, no-c-format
msgid ""
"In the previous example the fields where not added directly to Document but "
"we where delegating this task to the <classname>LuceneOptions</classname> "
"helper; this will apply the options you have selected on <literal>@Field</"
"literal>, like <literal>Store</literal> or <literal>TermVector</literal> "
"options, or apply the choosen <classname>@Boost</classname> value. It is "
"especially useful to encapsulate the complexity of <literal>COMPRESS</"
"literal> implementations so it's recommended to delegate to "
"<classname>LuceneOptions</classname> to add fields to the "
"<classname>Document</classname>, but nothing stops you from editing the "
"<classname>Document</classname> directly and ignore the "
"<classname>LuceneOptions</classname> in case you need to."
msgstr ""

#. Tag: para
#: mapping.xml:1048
#, no-c-format
msgid ""
"Classes like <classname>LuceneOptions</classname> are created to shield your "
"application from changes in Lucene API and simplify your code. Use them if "
"you can, but if you need more flexibility you're not required to."
msgstr ""

#. Tag: title
#: mapping.xml:1055
#, no-c-format
msgid "ClassBridge"
msgstr ""

#. Tag: para
#: mapping.xml:1057
#, no-c-format
msgid ""
"It is sometimes useful to combine more than one property of a given entity "
"and index this combination in a specific way into the Lucene index. The "
"<classname>@ClassBridge</classname> and <classname>@ClassBridge</classname> "
"annotations can be defined at the class level (as opposed to the property "
"level). In this case the custom field bridge implementation receives the "
"entity instance as the value parameter instead of a particular property. "
"Though not shown in this example, <classname>@ClassBridge</classname> "
"supports the <methodname>termVector</methodname> attribute discussed in "
"section <xref linkend=\"basic-mapping\"/>."
msgstr ""

#. Tag: title
#: mapping.xml:1069
#, no-c-format
msgid "Implementing a class bridge"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1071
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"<emphasis role=\"bold\">@ClassBridge</emphasis>(name=\"branchnetwork\",\n"
"             index=Index.TOKENIZED,\n"
"             store=Store.YES,\n"
"             impl = <emphasis role=\"bold\">CatFieldsClassBridge.class</"
"emphasis>,\n"
"             params = @Parameter( name=\"sepChar\", value=\" \" ) )\n"
"public class Department {\n"
"    private int id;\n"
"    private String network;\n"
"    private String branchHead;\n"
"    private String branch;\n"
"    private Integer maxEmployees\n"
"    ...\n"
"}\n"
"\n"
"public class CatFieldsClassBridge implements FieldBridge, "
"ParameterizedBridge {\n"
"    private String sepChar;\n"
"\n"
"    public void setParameterValues(Map parameters) {\n"
"        this.sepChar = (String) parameters.get( \"sepChar\" );\n"
"    }\n"
"\n"
"    <emphasis role=\"bold\">public void set(String name, Object value, "
"Document document, LuceneOptions luceneOptions)</emphasis> {\n"
"        // In this particular class the name of the new field was passed\n"
"        // from the name field of the ClassBridge Annotation. This is not\n"
"        // a requirement. It just works that way in this instance. The\n"
"        // actual name could be supplied by hard coding it below.\n"
"        Department dep = (Department) value;\n"
"        String fieldValue1 = dep.getBranch();\n"
"        if ( fieldValue1 == null ) {\n"
"            fieldValue1 = \"\";\n"
"        }\n"
"        String fieldValue2 = dep.getNetwork();\n"
"        if ( fieldValue2 == null ) {\n"
"            fieldValue2 = \"\";\n"
"        }\n"
"        String fieldValue = fieldValue1 + sepChar + fieldValue2;\n"
"        Field field = new Field( name, fieldValue, luceneOptions.getStore(), "
"luceneOptions.getIndex(), luceneOptions.getTermVector() );\n"
"        field.setBoost( luceneOptions.getBoost() );\n"
"        document.add( field );\n"
"   }\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:1074
#, no-c-format
msgid ""
"In this example, the particular <classname>CatFieldsClassBridge</classname> "
"is applied to the <literal>department</literal> instance, the field bridge "
"then concatenate both branch and network and index the concatenation."
msgstr ""

#. Tag: title
#: mapping.xml:1084 mapping.xml:1109
#, no-c-format
msgid "Providing your own id"
msgstr ""

#. Tag: para
#: mapping.xml:1087
#, no-c-format
msgid "This part of the documentation is a work in progress."
msgstr ""

#. Tag: para
#: mapping.xml:1090
#, no-c-format
msgid ""
"You can provide your own id for Hibernate Search if you are extending the "
"internals. You will have to generate a unique value so it can be given to "
"Lucene to be indexed. This will have to be given to Hibernate Search when "
"you create an org.hibernate.search.Work object - the document id is required "
"in the constructor."
msgstr ""

#. Tag: title
#: mapping.xml:1097
#, no-c-format
msgid "The ProvidedId annotation"
msgstr ""

#. Tag: para
#: mapping.xml:1099
#, no-c-format
msgid ""
"Unlike conventional Hibernate Search API and @DocumentId, this annotation is "
"used on the class and not a field. You also can provide your own bridge "
"implementation when you put in this annotation by calling the bridge() which "
"is on @ProvidedId. Also, if you annotate a class with @ProvidedId, your "
"subclasses will also get the annotation - but it is not done by using the "
"java.lang.annotations.@Inherited. Be sure however, to <emphasis>not</"
"emphasis> use this annotation with @DocumentId as your system will break."
msgstr ""

#. Tag: programlisting
#: mapping.xml:1111
#, no-c-format
msgid ""
"@ProvidedId (bridge = org.my.own.package.MyCustomBridge)\n"
"@Indexed\n"
"public class MyClass{\n"
"    @Field\n"
"    String MyString;\n"
"    ...\n"
"}"
msgstr ""

#. Tag: title
#: mapping.xml:1117
#, no-c-format
msgid "Programmatic API"
msgstr ""

#. Tag: para
#: mapping.xml:1120
#, no-c-format
msgid ""
"This feature is considered experimental. While stable code-wise, the API is "
"subject to change in the future."
msgstr ""

#. Tag: para
#: mapping.xml:1121
#, no-c-format
msgid ""
"Although the recommended approach for mapping indexed entities is to use "
"annotations, it is sometimes more convenient to use a different approach:"
msgstr ""

#. Tag: para
#: mapping.xml:1128
#, no-c-format
msgid ""
"the same entity is mapped differently depending on deployment needs "
"(customization for clients)"
msgstr ""

#. Tag: para
#: mapping.xml:1133
#, no-c-format
msgid ""
"some automatization process requires the dynamic mapping of many entities "
"sharing a common traits"
msgstr ""

#. Tag: para
#: mapping.xml:1138
#, no-c-format
msgid ""
"While it has been a popular demand in the past, the Hibernate team never "
"found the idea of an XML alternative to annotations appealing due to it's "
"heavy duplication, lack of code refactoring safety, because it did not cover "
"all the use case spectrum and because we are in the 21st century :)"
msgstr ""

#. Tag: para
#: mapping.xml:1144
#, no-c-format
msgid ""
"Th idea of a programmatic API was much more appealing and has now become a "
"reality. You can programmatically and safely define your mapping using a "
"programmatic API: you define entities and fields as indexable by using "
"mapping classes which effectively mirror the annotation concepts in "
"Hibernate Search. Note that fan(s) of XML approach can design their own "
"schema and use the programmatic API to create the mapping while parsing the "
"XML stream."
msgstr ""

#. Tag: para
#: mapping.xml:1152
#, no-c-format
msgid ""
"In order to use the programmatic model you must first construct a "
"<classname>SearchMapping</classname> object. This object is passed to "
"Hibernate Search via a property set to the <classname>Configuration </"
"classname>object. The property key is <literal>hibernate.search."
"model_mapping</literal> or it's type-safe representation "
"<classname>Environment.MODEL_MAPPING</classname>."
msgstr ""

#. Tag: programlisting
#: mapping.xml:1159
#, no-c-format
msgid ""
"SearchMapping mapping = new SearchMapping();\n"
"[...]\n"
"configuration.setProperty( Environment.MODEL_MAPPING, mapping );\n"
"\n"
"//or in JPA\n"
"SearchMapping mapping = new SearchMapping();\n"
"[...]\n"
"Map&lt;String,String&gt; properties = new HashMap&lt;String,String)(1);\n"
"properties.put( Environment.MODEL_MAPPING, mapping );\n"
"EntityManagerFactory emf = Persistence.createEntityManagerFactory( \"userPU"
"\", properties );"
msgstr ""

#. Tag: para
#: mapping.xml:1161
#, no-c-format
msgid ""
"The <classname>SearchMapping</classname> is the root object which contains "
"all the necessary indexable entities and fields. From there, the "
"<classname>SearchMapping</classname> object exposes a fluent (and thus "
"intuitive) API to express your mappings: it contextually exposes the "
"relevant mapping options in a type-safe way, just let your IDE "
"autocompletion feature guide you through."
msgstr ""

#. Tag: para
#: mapping.xml:1168
#, no-c-format
msgid ""
"Today, the programmatic API cannot be used on a class annotated with "
"Hibernate Search annotations, chose one approach or the other. Also note "
"that the same default values apply in annotations and the programmatic API. "
"For example, the <methodname>@Field.name</methodname> is defaulted to the "
"property name and does not have to be set."
msgstr ""

#. Tag: para
#: mapping.xml:1174
#, no-c-format
msgid ""
"Each core concept of the programmatic API has a corresponding example to "
"depict how the same definition would look using annotation. Therefore seeing "
"an annotation example of the programmatic approach should give you a clear "
"picture of what Hibernate Search will build with the marked entities and "
"associated properties."
msgstr ""

#. Tag: title
#: mapping.xml:1181
#, no-c-format
msgid "Mapping an entity as indexable"
msgstr ""

#. Tag: para
#: mapping.xml:1183
#, no-c-format
msgid ""
"The first concept of the programmatic API is to define an entity as "
"indexable. Using the annotation approach a user would mark the entity as "
"<classname>@Indexed</classname>, the following example demonstrates how to "
"programmatically achieve this."
msgstr ""

#. Tag: title
#: mapping.xml:1189
#, no-c-format
msgid "Marking an entity indexable"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1191
#, no-c-format
msgid ""
"SearchMapping mapping = new SearchMapping();\n"
"\n"
"mapping.entity(Address.class)\n"
"           .indexed()\n"
"               .indexName(\"Address_Index\"); //optional\n"
"\n"
"cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1193
#, no-c-format
msgid ""
"As you can see you must first create a <classname>SearchMapping</classname> "
"object which is the root object that is then passed to the "
"<classname>Configuration</classname> object as property. You must declare an "
"entity and if you wish to make that entity as indexable then you must call "
"the <methodname>indexed()</methodname> method. The <methodname>indexed() </"
"methodname>method has an optional <methodname>indexName(String indexName)</"
"methodname> which can be used to change the default index name that is "
"created by Hibernate Search. Using the annotation model the above can be "
"achieved as:"
msgstr ""

#. Tag: title
#: mapping.xml:1205
#, no-c-format
msgid "Annotation example of indexing entity"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1207
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed(index=\"Address_Index\")\n"
"public class Address {\n"
"....\n"
"}"
msgstr ""

#. Tag: title
#: mapping.xml:1213
#, no-c-format
msgid "Adding DocumentId to indexed entity"
msgstr ""

#. Tag: para
#: mapping.xml:1215
#, no-c-format
msgid "To set a property as a document id:"
msgstr ""

#. Tag: title
#: mapping.xml:1218
#, no-c-format
msgid "Enabling document id with programmatic model"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1220
#, no-c-format
msgid ""
"SearchMapping mapping = new SearchMapping();\n"
"\n"
"mapping.entity(Address.class).indexed()\n"
"           .property(\"addressId\", ElementType.FIELD) //field access\n"
"               .documentId()\n"
"                   .name(\"id\");\n"
"\n"
"cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping);"
msgstr ""

#. Tag: para
#: mapping.xml:1222
#, no-c-format
msgid ""
"The above is equivalent to annotating a property in the entity as "
"<classname>@DocumentId</classname> as seen in the following example:"
msgstr ""

#. Tag: title
#: mapping.xml:1227
#, no-c-format
msgid "DocumentId annotation definition"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1229
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"public class Address {\n"
" @Id\n"
" @GeneratedValue\n"
" @DocumentId(name=\"id\")\n"
" private Long addressId;\n"
"\n"
" ....\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:1231
#, no-c-format
msgid "The next section demonstrates how to programmatically define analyzers."
msgstr ""

#. Tag: title
#: mapping.xml:1236
#, no-c-format
msgid "Defining analyzers"
msgstr ""

#. Tag: para
#: mapping.xml:1238
#, no-c-format
msgid ""
"Analyzers can be programmatically defined using the <methodname>analyzerDef"
"(String analyzerDef, Class&lt;? extends TokenizerFactory&gt; "
"tokenizerFactory) </methodname>method. This method also enables you to "
"define filters for the analyzer definition. Each filter that you define can "
"optionally take in parameters as seen in the following example :"
msgstr ""

#. Tag: title
#: mapping.xml:1246
#, no-c-format
msgid "Defining analyzers using programmatic model"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1248
#, no-c-format
msgid ""
"SearchMapping mapping = new SearchMapping();\n"
"\n"
"mapping\n"
"    <emphasis role=\"bold\">.analyzerDef( \"ngram\", "
"StandardTokenizerFactory.class )\n"
"        .filter( LowerCaseFilterFactory.class )\n"
"        .filter( NGramFilterFactory.class )\n"
"            .param( \"minGramSize\", \"3\" )\n"
"            .param( \"maxGramSize\", \"3\" )\n"
"    .analyzerDef( \"en\", StandardTokenizerFactory.class )\n"
"        .filter( LowerCaseFilterFactory.class )\n"
"        .filter( EnglishPorterFilterFactory.class )\n"
"    .analyzerDef( \"de\", StandardTokenizerFactory.class )\n"
"        .filter( LowerCaseFilterFactory.class )\n"
"        .filter( GermanStemFilterFactory.class )</emphasis>\n"
"    .entity(Address.class).indexed()\n"
"        .property(\"addressId\", ElementType.METHOD) //getter access\n"
"            .documentId()\n"
"                .name(\"id\");\n"
"\n"
"cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1250
#, no-c-format
msgid ""
"The analyzer mapping defined above is equivalent to the annotation model "
"using <classname>@AnalyzerDef</classname> in conjunction with "
"<classname>@AnalyzerDefs</classname>:"
msgstr ""

#. Tag: title
#: mapping.xml:1254
#, no-c-format
msgid "Analyzer definition using annotation"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1256
#, no-c-format
msgid ""
"@Indexed\n"
"@Entity\n"
"@AnalyzerDefs({\n"
"  @AnalyzerDef(name = \"ngram\",\n"
"    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),\n"
"    filters = {\n"
"      @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
"      @TokenFilterDef(factory = NGramFilterFactory.class, \n"
"        params = {\n"
"          @Parameter(name = \"minGramSize\",value = \"3\"),\n"
"          @Parameter(name = \"maxGramSize\",value = \"3\") \n"
"       })\n"
"   }),\n"
"  @AnalyzerDef(name = \"en\",\n"
"    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),\n"
"    filters = {\n"
"      @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
"      @TokenFilterDef(factory = EnglishPorterFilterFactory.class)\n"
"   }),\n"
"\n"
"  @AnalyzerDef(name = \"de\",\n"
"    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),\n"
"    filters = {\n"
"      @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
"      @TokenFilterDef(factory = GermanStemFilterFactory.class)\n"
"  })\n"
"\n"
"})\n"
"public class Address {\n"
"...\n"
"}"
msgstr ""

#. Tag: title
#: mapping.xml:1261
#, no-c-format
msgid "Defining full text filter definitions"
msgstr ""

#. Tag: para
#: mapping.xml:1263
#, no-c-format
msgid ""
"The programmatic API provides easy mechanism for defining full text filter "
"definitions which is available via <classname>@FullTextFilterDef</classname> "
"and <classname>@FullTextFilterDefs</classname>. Note that contrary to the "
"annotation equivalent, full text filter definitions are a global construct "
"and are not tied to an entity. The next example depicts the creation of full "
"text filter definition using the <methodname>fullTextFilterDef </"
"methodname>method."
msgstr ""

#. Tag: title
#: mapping.xml:1273
#, no-c-format
msgid "Defining full text definition programmatically"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1275
#, no-c-format
msgid ""
"SearchMapping mapping = new SearchMapping();\n"
"\n"
"mapping\n"
"    .analyzerDef( \"en\", StandardTokenizerFactory.class )\n"
"        .filter( LowerCaseFilterFactory.class )\n"
"        .filter( EnglishPorterFilterFactory.class )\n"
"    <emphasis role=\"bold\">.fullTextFilterDef(\"security\", "
"SecurityFilterFactory.class)\n"
"            .cache(FilterCacheModeType.INSTANCE_ONLY)</emphasis>\n"
"    .entity(Address.class)\n"
"        .indexed()\n"
"        .property(\"addressId\", ElementType.METHOD)\n"
"            .documentId()\n"
"                .name(\"id\")\n"
"        .property(\"street1\", ElementType.METHOD)\n"
"            .field()\n"
"                .analyzer(\"en\")\n"
"                .store(Store.YES)\n"
"            .field()\n"
"                .name(\"address_data\")\n"
"                .analyzer(\"en\")\n"
"                .store(Store.NO);\n"
"\n"
"cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1277
#, no-c-format
msgid ""
"The previous example can effectively been seen as annotating your entity "
"with <classname>@FullTextFilterDef</classname> like below:"
msgstr ""

#. Tag: title
#: mapping.xml:1281
#, no-c-format
msgid "Using annotation to define full text filter definition"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1284
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"@AnalyzerDefs({\n"
"  @AnalyzerDef(name = \"en\",\n"
"    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),\n"
"    filters = {\n"
"      @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
"      @TokenFilterDef(factory = EnglishPorterFilterFactory.class)\n"
"   })\n"
"})\n"
"@FullTextFilterDefs({\n"
" @FullTextFilterDef(name = \"security\", impl = SecurityFilterFactory.class, "
"cache = FilterCacheModeType.INSTANCE_ONLY)\n"
"})\n"
"public class Address {\n"
" \n"
" @Id\n"
" @GeneratedValue\n"
" @DocumentId(name=\"id\")\n"
" pubblic Long getAddressId() {...};\n"
"\n"
" @Fields({\n"
"      @Field(index=Index.TOKENIZED, store=Store.YES, \n"
"             analyzer=@Analyzer(definition=\"en\")),\n"
"      @Field(name=\"address_data\", analyzer=@Analyzer(definition=\"en\"))\n"
" })\n"
" public String getAddress1() {...};\n"
"\n"
" ......\n"
" \n"
"}"
msgstr ""

#. Tag: title
#: mapping.xml:1289
#, no-c-format
msgid "Defining fields for indexing"
msgstr ""

#. Tag: para
#: mapping.xml:1291
#, no-c-format
msgid ""
"When defining fields for indexing using the programmatic API, call "
"<methodname>field()</methodname> on the <methodname>property(String "
"propertyName, ElementType elementType)</methodname> method. From "
"<methodname>field()</methodname> you can specify the <methodname>name, "
"index</methodname>, <methodname>store</methodname>, <methodname>bridge</"
"methodname> and <methodname>analyzer</methodname> definitions."
msgstr ""

#. Tag: title
#: mapping.xml:1300
#, no-c-format
msgid "Indexing fields using programmatic API"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1302
#, no-c-format
msgid ""
"SearchMapping mapping = new SearchMapping();\n"
"\n"
"mapping\n"
"    .analyzerDef( \"en\", StandardTokenizerFactory.class )\n"
"        .filter( LowerCaseFilterFactory.class )\n"
"        .filter( EnglishPorterFilterFactory.class )\n"
"    .entity(Address.class).indexed()\n"
"        .property(\"addressId\", ElementType.METHOD)\n"
"            .documentId()\n"
"                .name(\"id\")\n"
"        .property(\"street1\", ElementType.METHOD)\n"
"            <emphasis role=\"bold\">.field()\n"
"                .analyzer(\"en\")\n"
"                .store(Store.YES)\n"
"                .index(Index.TOKENIZED) //no useful here as it's the "
"default\n"
"            .field()\n"
"                .name(\"address_data\")\n"
"                .analyzer(\"en\");</emphasis>\n"
"\n"
"cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1304
#, no-c-format
msgid ""
"The above example of marking fields as indexable is equivalent to defining "
"fields using <classname>@Field</classname> as seen below:"
msgstr ""

#. Tag: title
#: mapping.xml:1308
#, no-c-format
msgid "Indexing fields using annotation"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1310
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"@AnalyzerDefs({\n"
"  @AnalyzerDef(name = \"en\",\n"
"    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),\n"
"    filters = {\n"
"      @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
"      @TokenFilterDef(factory = EnglishPorterFilterFactory.class)\n"
"   })\n"
"})\n"
"public class Address {\n"
" \n"
" @Id\n"
" @GeneratedValue\n"
" @DocumentId(name=\"id\")\n"
" private Long getAddressId() {...};\n"
"\n"
" @Fields({\n"
"      @Field(index=Index.TOKENIZED, store=Store.YES, \n"
"             analyzer=@Analyzer(definition=\"en\")),\n"
"      @Field(name=\"address_data\", analyzer=@Analyzer(definition=\"en\"))\n"
" })\n"
" public String getAddress1() {...}\n"
"\n"
" ......\n"
"}"
msgstr ""

#. Tag: title
#: mapping.xml:1317
#, no-c-format
msgid "Programmatically defining embedded entities"
msgstr ""

#. Tag: para
#: mapping.xml:1319
#, no-c-format
msgid ""
"In this section you will see how to programmatically define entities to be "
"embedded into the indexed entity similar to using the "
"<classname>@IndexEmbedded</classname> model. In order to define this you "
"must mark the property as <methodname>indexEmbedded. </methodname>The is the "
"option to add a prefix to the embedded entity definition and this can be "
"done by calling <methodname>prefix</methodname> as seen in the example below:"
msgstr ""

#. Tag: title
#: mapping.xml:1328
#, no-c-format
msgid "Programmatically defining embedded entites"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1330
#, no-c-format
msgid ""
"SearchMapping mapping = new SearchMapping();\n"
"\n"
"mappping\n"
"    .entity(ProductCatalog.class)\n"
"        .indexed()\n"
"        .property(\"catalogId\", ElementType.METHOD)\n"
"            .documentId()\n"
"                .name(\"id\")\n"
"        .property(\"title\", ElementType.METHOD)\n"
"            .field()\n"
"                .index(Index.TOKENIZED)\n"
"                .store(Store.NO)\n"
"        .property(\"description\", ElementType.METHOD)\n"
"             .field()\n"
"                 .index(Index.TOKENIZED)\n"
"                 .store(Store.NO)\n"
"        .property(\"items\", ElementType.METHOD)\n"
"            <emphasis role=\"bold\">.indexEmbedded()\n"
"                .prefix(\"catalog.items\"); //optional</emphasis>\n"
"\n"
"cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1332
#, no-c-format
msgid ""
"The next example shows the same definition using annotation "
"(<classname>@IndexEmbedded</classname>):"
msgstr ""

#. Tag: title
#: mapping.xml:1335
#, no-c-format
msgid "Using @IndexEmbedded"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1337
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"public class ProductCatalog {\n"
" @Id\n"
" @GeneratedValue\n"
" @DocumentId(name=\"id\")\n"
" public Long getCatalogId() {...}\n"
" \n"
" @Field(store=Store.NO, index=Index.TOKENIZED)\n"
" public String getTitle() {...}\n"
"\n"
" @Field(store=Store.NO, index=Index.TOKENIZED)\n"
" public String getDescription();\n"
" \n"
" @OneToMany(fetch = FetchType.LAZY)\n"
" @IndexColumn(name = \"list_position\")\n"
" @Cascade(org.hibernate.annotations.CascadeType.ALL)\n"
" @IndexEmbedded(prefix=\"catalog.items\")\n"
" public List&lt;Item&gt; getItems() {...}\n"
"\n"
" ...\n"
"\n"
"}"
msgstr ""

#. Tag: title
#: mapping.xml:1342
#, no-c-format
msgid "Contained In definition"
msgstr ""

#. Tag: para
#: mapping.xml:1344
#, no-c-format
msgid ""
"<classname>@ContainedIn</classname> can be define as seen in the example "
"below:"
msgstr ""

#. Tag: title
#: mapping.xml:1346
#, no-c-format
msgid "Programmatically defining ContainedIn"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1348
#, no-c-format
msgid ""
"SearchMapping mapping = new SearchMapping();\n"
"\n"
"mappping\n"
"    .entity(ProductCatalog.class)\n"
"        .indexed()\n"
"        .property(\"catalogId\", ElementType.METHOD)\n"
"            .documentId()\n"
"        .property(\"title\", ElementType.METHOD)\n"
"            .field()\n"
"        .property(\"description\", ElementType.METHOD)\n"
"            .field()\n"
"        .property(\"items\", ElementType.METHOD)\n"
"            .indexEmbedded()\n"
"\n"
"    .entity(Item.class)\n"
"        .property(\"description\", ElementType.METHOD)\n"
"            .field()\n"
"        .property(\"productCatalog\", ElementType.METHOD)\n"
"            <emphasis role=\"bold\">.containedIn()</emphasis>;\n"
"\n"
"cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1350
#, no-c-format
msgid ""
"This is equivalent to defining <classname>@ContainedIn</classname> in your "
"entity:"
msgstr ""

#. Tag: title
#: mapping.xml:1354
#, no-c-format
msgid "Annotation approach for ContainedIn"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1356
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"public class ProductCatalog {\n"
" \n"
" @Id\n"
" @GeneratedValue\n"
" @DocumentId\n"
" public Long getCatalogId() {...}\n"
" \n"
" @Field\n"
" public String getTitle() {...}\n"
"\n"
" @Field\n"
" public String getDescription() {...}\n"
" \n"
" @OneToMany(fetch = FetchType.LAZY)\n"
" @IndexColumn(name = \"list_position\")\n"
" @Cascade(org.hibernate.annotations.CascadeType.ALL)\n"
" @IndexEmbedded\n"
" private List&lt;Item&gt; getItems() {...}\n"
"\n"
" ...\n"
"\n"
"}\n"
"\n"
"\n"
"@Entity\n"
"public class Item {\n"
" \n"
" @Id\n"
" @GeneratedValue\n"
" private Long itemId;\n"
"\n"
" @Field\n"
" public String getDescription() {...}\n"
" \n"
" @ManyToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )\n"
" @ContainedIn\n"
" public ProductCatalog getProductCatalog() {...}\n"
"\n"
" ...\n"
"}"
msgstr ""

#. Tag: title
#: mapping.xml:1362
#, no-c-format
msgid "Date/Calendar Bridge"
msgstr ""

#. Tag: para
#: mapping.xml:1364
#, no-c-format
msgid ""
"In order to define a calendar or date bridge mapping, call the "
"<methodname>dateBridge(Resolution resolution) </methodname>or "
"<methodname>calendarBridge(Resolution resolution)</methodname> methods after "
"you have defined a <methodname>field()</methodname> in the "
"<classname>SearchMapping </classname>hierarchy."
msgstr ""

#. Tag: title
#: mapping.xml:1371
#, no-c-format
msgid "Programmatic model for defining calendar/date bridge"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1373
#, no-c-format
msgid ""
"SearchMapping mapping = new SearchMapping();\n"
"\n"
"mapping\n"
"    .entity(Address.class)\n"
"        .indexed()\n"
"        .property(\"addressId\", ElementType.FIELD)\n"
"            .documentId()\n"
"    .property(\"street1\", ElementType.FIELD()\n"
"        .field()\n"
"    .property(\"createdOn\", ElementType.FIELD)\n"
"        .field()\n"
"        <emphasis role=\"bold\">.dateBridge(Resolution.DAY)</emphasis>\n"
"    .property(\"lastUpdated\", ElementType.FIELD)\n"
"        <emphasis role=\"bold\">.calendarBridge(Resolution.DAY)</emphasis>;\n"
"\n"
"cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1375
#, no-c-format
msgid ""
"See below for defining the above using <classname>@CalendarBridge</"
"classname> and <classname>@DateBridge</classname>:"
msgstr ""

#. Tag: title
#: mapping.xml:1379
#, no-c-format
msgid "@CalendarBridge and @DateBridge definition"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1381
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"public class Address {\n"
" \n"
" @Id\n"
" @GeneratedValue\n"
" @DocumentId\n"
" private Long addressId;\n"
"\n"
" @Field\n"
" private String address1;\n"
"\n"
" @Field\n"
" @DateBridge(resolution=Resolution.DAY)\n"
" private Date createdOn;\n"
"\n"
" @CalendarBridge(resolution=Resolution.DAY)\n"
" private Calendar lastUpdated;\n"
"\n"
" ...\n"
"}"
msgstr ""

#. Tag: title
#: mapping.xml:1386
#, no-c-format
msgid "Defining bridges"
msgstr ""

#. Tag: para
#: mapping.xml:1388
#, no-c-format
msgid ""
"It is possible to associate bridges to programmatically defined fields. When "
"you define a <methodname>field()</methodname> programmatically you can use "
"the <methodname>bridge(Class&lt;?&gt; impl)</methodname> to associate a "
"<classname>FieldBridge </classname>implementation class. The bridge method "
"also provides optional methods to include any parameters required for the "
"bridge class. The below shows an example of programmatically defining a "
"bridge:"
msgstr ""

#. Tag: title
#: mapping.xml:1398
#, no-c-format
msgid "Defining field bridges programmatically"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1400
#, no-c-format
msgid ""
"SearchMapping mapping = new SearchMapping();\n"
"\n"
"mapping\n"
"    .entity(Address.class)\n"
"        .indexed()\n"
"        .property(\"addressId\", ElementType.FIELD)\n"
"            .documentId()\n"
"        .property(\"street1\", ElementType.FIELD)\n"
"            .field()\n"
"            .field()\n"
"                .name(\"street1_abridged\")\n"
"                <emphasis role=\"bold\">.bridge( ConcatStringBridge.class )\n"
"                    .param( \"size\", \"4\" )</emphasis>;\n"
" \n"
"cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1402
#, no-c-format
msgid ""
"The above can equally be defined using annotations, as seen in the next "
"example."
msgstr ""

#. Tag: title
#: mapping.xml:1406
#, no-c-format
msgid "Defining field bridges using annotation"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1408
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"\n"
"public class Address {\n"
" \n"
" @Id\n"
" @GeneratedValue\n"
" @DocumentId(name=\"id\")\n"
" private Long addressId;\n"
"\n"
" @Fields({\n"
"      @Field,\n"
"      @Field(name=\"street1_abridged\", \n"
"             bridge = @FieldBridge( impl = ConcatStringBridge.class, \n"
"             params = @Parameter( name=\"size\", value=\"4\" ))\n"
" })\n"
" private String address1;\n"
"\n"
" ...\n"
"}"
msgstr ""

#. Tag: title
#: mapping.xml:1414
#, no-c-format
msgid "Mapping class bridge"
msgstr ""

#. Tag: para
#: mapping.xml:1416
#, no-c-format
msgid ""
"You can define class bridges on entities programmatically. This is shown in "
"the next example:"
msgstr ""

#. Tag: title
#: mapping.xml:1420
#, no-c-format
msgid "Defining class briges using API"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1422
#, no-c-format
msgid ""
"SearchMapping mapping = new SearchMapping();\n"
"\n"
"mapping\n"
"    .entity(Departments.class)\n"
"<emphasis>       .classBridge(CatDeptsFieldsClassBridge.class)\n"
"         .name(\"branchnetwork\")\n"
"         .index(Index.TOKENIZED)\n"
"         .store(Store.YES)\n"
"         .param(\"sepChar\", \" \")\n"
"      .classBridge(EquipmentType.class)\n"
"         .name(\"equiptype\")\n"
"         .index(Index.TOKENIZED)\n"
"         .store(Store.YES)\n"
"         .param(\"C\", \"Cisco\")\n"
"         .param(\"D\", \"D-Link\")\n"
"         .param(\"K\", \"Kingston\")\n"
"         .param(\"3\", \"3Com\")</emphasis>\n"
"      .indexed();\n"
"\n"
"cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1424
#, no-c-format
msgid ""
"The above is similar to using <classname>@ClassBridge </classname>as seen in "
"the next example:"
msgstr ""

#. Tag: title
#: mapping.xml:1426
#, no-c-format
msgid "Using @ClassBridge"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1428
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"@ClassBridges ( {\n"
"  @ClassBridge(name=\"branchnetwork\",\n"
"     index= Index.TOKENIZED,\n"
"     store= Store.YES,\n"
"     impl = CatDeptsFieldsClassBridge.class,\n"
"     params = @Parameter( name=\"sepChar\", value=\" \" ) ),\n"
"  @ClassBridge(name=\"equiptype\",\n"
"     index= Index.TOKENIZED,\n"
"     store= Store.YES,\n"
"     impl = EquipmentType.class,\n"
"     params = {@Parameter( name=\"C\", value=\"Cisco\" ),\n"
"        @Parameter( name=\"D\", value=\"D-Link\" ),\n"
"        @Parameter( name=\"K\", value=\"Kingston\" ),\n"
"        @Parameter( name=\"3\", value=\"3Com\" )\n"
"   })\n"
"})\n"
"public class Departments {\n"
"\n"
"....\n"
"\n"
"}"
msgstr ""

#. Tag: title
#: mapping.xml:1434
#, no-c-format
msgid "Mapping dynamic boost"
msgstr ""

#. Tag: para
#: mapping.xml:1436
#, no-c-format
msgid ""
"You can apply a dynamic boost factor on either a field or a whole entity:"
msgstr ""

#. Tag: title
#: mapping.xml:1440
#, no-c-format
msgid "DynamicBoost mapping using programmatic model"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1442
#, no-c-format
msgid ""
"SearchMapping mapping = new SearchMapping();\n"
"\n"
"mapping\n"
"  .entity(DynamicBoostedDescLibrary.class)\n"
"   .indexed()\n"
"   <emphasis>.dynamicBoost(CustomBoostStrategy.class)</emphasis>\n"
"  .property(\"libraryId\", ElementType.FIELD)\n"
"    .documentId().name(\"id\")\n"
"  .property(\"name\", ElementType.FIELD)\n"
"    <emphasis>.dynamicBoost(CustomFieldBoostStrategy.class)</emphasis>;\n"
"    .field()\n"
"      .store(Store.YES)\n"
"\n"
"cfg.getProperties().put( \"hibernate.search.model_mapping\", mapping );"
msgstr ""

#. Tag: para
#: mapping.xml:1444
#, no-c-format
msgid ""
"The next example shows the equivalent mapping using the "
"<classname>@DynamicBoost</classname> annotation:"
msgstr ""

#. Tag: title
#: mapping.xml:1446
#, no-c-format
msgid "Using the @DynamicBoost"
msgstr ""

#. Tag: programlisting
#: mapping.xml:1448
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"@DynamicBoost(impl = CustomBoostStrategy.class)\n"
"public class DynamicBoostedDescriptionLibrary {\n"
"\n"
" @Id\n"
" @GeneratedValue\n"
" @DocumentId\n"
" private int id;\n"
"\n"
" private float dynScore;\n"
" \n"
" @Field(store = Store.YES)\n"
" @DynamicBoost(impl = CustomFieldBoostStrategy.class)\n"
" private String name;\n"
"\n"
" public DynamicBoostedDescriptionLibrary() {\n"
"  dynScore = 1.0f;\n"
" }\n"
"  \n"
" .......\n"
"\n"
"}"
msgstr ""
